
!function n(t,e,o){function i(u,f){if(!e[u]){if(!t[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(r)return r(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var a=e[u]={exports:{}};t[u][0].call(a.exports,function(n){var e=t[u][1][n];return i(e?e:n)},a,a.exports,n,t,e,o)}return e[u].exports}for(var r="function"==typeof require&&require,u=0;u<o.length;u++)i(o[u]);return i}({1:[function(n,t){function e(){}var o=t.exports={};o.nextTick=function(){var n="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(n)return function(n){return window.setImmediate(n)};if(t){var e=[];return window.addEventListener("message",function(n){var t=n.source;if((t===window||null===t)&&"process-tick"===n.data&&(n.stopPropagation(),e.length>0)){var o=e.shift();o()}},!0),function(n){e.push(n),window.postMessage("process-tick","*")}}return function(n){setTimeout(n,0)}}(),o.title="browser",o.browser=!0,o.env={},o.argv=[],o.on=e,o.addListener=e,o.once=e,o.off=e,o.removeListener=e,o.removeAllListeners=e,o.emit=e,o.binding=function(){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(){throw new Error("process.chdir is not supported")}},{}],2:[function(n,t){function e(n){function t(n){return null===c?void a.push(n):void r(function(){var t=c?n.onFulfilled:n.onRejected;if(null===t)return void(c?n.resolve:n.reject)(s);var e;try{e=t(s)}catch(o){return void n.reject(o)}n.resolve(e)})}function e(n){try{if(n===l)throw new TypeError("A promise cannot be resolved with itself.");if(n&&("object"==typeof n||"function"==typeof n)){var t=n.then;if("function"==typeof t)return void i(t.bind(n),e,u)}c=!0,s=n,f()}catch(o){u(o)}}function u(n){c=!1,s=n,f()}function f(){for(var n=0,e=a.length;e>n;n++)t(a[n]);a=null}if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof n)throw new TypeError("not a function");var c=null,s=null,a=[],l=this;this.then=function(n,e){return new l.constructor(function(i,r){t(new o(n,e,i,r))})},i(n,e,u)}function o(n,t,e,o){this.onFulfilled="function"==typeof n?n:null,this.onRejected="function"==typeof t?t:null,this.resolve=e,this.reject=o}function i(n,t,e){var o=!1;try{n(function(n){o||(o=!0,t(n))},function(n){o||(o=!0,e(n))})}catch(i){if(o)return;o=!0,e(i)}}var r=n("asap");t.exports=e},{asap:4}],3:[function(n,t){function e(n){this.then=function(t){return"function"!=typeof t?this:new o(function(e,o){i(function(){try{e(t(n))}catch(i){o(i)}})})}}var o=n("./core.js"),i=n("asap");t.exports=o,e.prototype=o.prototype;var r=new e(!0),u=new e(!1),f=new e(null),c=new e(void 0),s=new e(0),a=new e("");o.resolve=function(n){if(n instanceof o)return n;if(null===n)return f;if(void 0===n)return c;if(n===!0)return r;if(n===!1)return u;if(0===n)return s;if(""===n)return a;if("object"==typeof n||"function"==typeof n)try{var t=n.then;if("function"==typeof t)return new o(t.bind(n))}catch(i){return new o(function(n,t){t(i)})}return new e(n)},o.all=function(n){var t=Array.prototype.slice.call(n);return new o(function(n,e){function o(r,u){try{if(u&&("object"==typeof u||"function"==typeof u)){var f=u.then;if("function"==typeof f)return void f.call(u,function(n){o(r,n)},e)}t[r]=u,0===--i&&n(t)}catch(c){e(c)}}if(0===t.length)return n([]);for(var i=t.length,r=0;r<t.length;r++)o(r,t[r])})},o.reject=function(n){return new o(function(t,e){e(n)})},o.race=function(n){return new o(function(t,e){n.forEach(function(n){o.resolve(n).then(t,e)})})},o.prototype["catch"]=function(n){return this.then(null,n)}},{"./core.js":2,asap:4}],4:[function(n,t){(function(n){function e(){for(;i.next;){i=i.next;var n=i.task;i.task=void 0;var t=i.domain;t&&(i.domain=void 0,t.enter());try{n()}catch(o){if(c)throw t&&t.exit(),setTimeout(e,0),t&&t.enter(),o;setTimeout(function(){throw o},0)}t&&t.exit()}u=!1}function o(t){r=r.next={task:t,domain:c&&n.domain,next:null},u||(u=!0,f())}var i={task:void 0,next:null},r=i,u=!1,f=void 0,c=!1;if("undefined"!=typeof n&&n.nextTick)c=!0,f=function(){n.nextTick(e)};else if("function"==typeof setImmediate)f="undefined"!=typeof window?setImmediate.bind(window,e):function(){setImmediate(e)};else if("undefined"!=typeof MessageChannel){var s=new MessageChannel;s.port1.onmessage=e,f=function(){s.port2.postMessage(0)}}else f=function(){setTimeout(e,0)};t.exports=o}).call(this,n("_process"))},{_process:1}],5:[function(){"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(){var n=arguments.length?this.then.apply(this,arguments):this;n.then(null,function(n){setTimeout(function(){throw n},0)})})},{}],6:[function(n){n("asap");"undefined"==typeof Promise&&(Promise=n("./lib/core.js"),n("./lib/es6-extensions.js")),n("./polyfill-done.js")},{"./lib/core.js":2,"./lib/es6-extensions.js":3,"./polyfill-done.js":5,asap:4}]},{},[6]);
//# sourceMappingURL=promise-6.0.0.min.js.map
;
define("Promise", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Promise;
    };
}(this)));

/*
 * 0: state: initiating, game created
 * 1: player initiated, state: running, \
 * 2: game_start called > request p1,p2 result
 * 3: (both player return result) check result
 * 4: 
 */
define('js/game.js',['Promise'],
function(Promise){
  function debug(message){
    console.error(message.stack);
    throw message;
  }
  /**
   * time a promise and return 3 if time exceed.
   * Designed to wrap player.getHand
   * @param {Promise} promise to be timed starting from the call
   * @param {Long} period max time in millisecond to spend for the promise,
   * 0 means no time limit.
   * @param {function} finish callback at the end of the process
   * @return {Promise} either normal return or 3 (when time exceeds)
   */
  /**
   * list errors thrown:
   * no one finish
   * no more turns
   * (error thrown by player)
   * @param {Promise} g1 first player
   * @param {Promise} g2 second player
   * @param {function} start to be called at the beginning of each round.
   * `this` is the game
   * @param {function} finish1 to be called when player1 finishes round
   * @param {function} finish2 same as finish1, but for player2
   * @param {function} end 
   * `this` is the game
   * @return {object} representation of game state
   */
  return function(g1,g2,period,start,finish1,finish2,end,n)
  {
    var f=
    {
      player1:undefined,
      player2:undefined,
      history:[],
      history2:[],
      promise:undefined,
      time:0,
      terminate:undefined,
      state:"initiating"
    };
    f.terminate=function(message){
      console.debug("state: "+this.state);
      switch(this.state){
        case "initiating":
          
        break;
        case "running":
          this.player1.stop();
          this.player2.stop();
        break;
        case "stopped":
          console.debug("state: "+this.state);
          return;
      }
      this.state="stopped";
      end.call(this,message);
    };
    var getHandWrapper=function(promise,period,finish)
    {
      if(period<=0){
        return promise;
      }
      return new Promise(function(a,b){//timeout
        promise.then(a);
        window.setTimeout(function(){b("time out");},period);
      }).catch(function(error){
        return 3;
      })
      .then(function(rtn){//update finish
        if(f.state=="stopped"){
          return;
        }
        finish();
        return rtn;
      });
    };
    //REALLY COMPLICATED
    var update=function (h0,h1,dt)
    {
      if(n--===0){
        f.terminate("no more turns");
        return;
        //return Promise.reject("no more turns");
      }

      start.call(f);
      return Promise.all(
      [
        getHandWrapper.call(this,f.player1.getHand(h0,h1,dt),period,finish1),
        getHandWrapper.call(this,f.player2.getHand(h1,h0,dt),period,finish2)
      ])
      .then(function(hs)
      {
        if(f.state=="stopped"){
          return;
        }
        if(hs[0]===3||hs[1]===3){
          f.terminate("no one finish");
          return;
        }
        var tmp=f.time;
        f.time=Date.now();
        tmp=f.time-tmp;
        tmp=Math.log(tmp/64,1.5)|0;//IMPORTANT
        if(tmp>15){tmp=15;}
        if(tmp<0){tmp=0;}
        f.history.push((hs[0]&3)+(hs[1]&3)*4+tmp*16);
        f.promise=update(hs[0],hs[1],tmp);
        return;
      })
      //.catch(debug)
      .catch(function(message){
        f.terminate(message); 
      });
    };
    f.promise=Promise.all([g1,g2])
    .then(function(ps)
    {//without catch error, do nothing when error
      if(f.state==="stopped"){
        return;
      }
      f.player1=ps[0];
      f.player2=ps[1];
      f.time=Date.now();
      f.state="running";
      return update(3,3,0);
    })
    //.catch(debug)
    .catch(function(message){
      f.terminate(message); 
    });
    return f;
  };
});

define('js/PlayerError.js',[],
function(){
  var PlayerError=function(message, data){

    this.message="PLAYER: "+message;
    this.data=data;
  };
  PlayerError.prototype=new Error();
  return PlayerError;
});

define('js/text_to_url.js',[],function(){
  var URL = window.URL || window.webkitURL;
  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
  return function(text,type){
    if(!type){
      type="";
    }
    var blob;
    try {
        blob = new Blob([text], {type: type});
    } catch (e)  // Backwards-compatibility
    {
        //window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(text);
        blob = blob.getBlob();
    }
    return URL.createObjectURL(blob);
  };
});


/**
 * It acts like bank.
 * It stores items and return a unique key to retreive the item
 * The key is unique across all token objects
 * You can delete item by calling `delete token[key]`
 * To remove all key, simply reconstruct a new Token()
 * @module js/tokens
 */
define('js/tokens.js',[],function(){
  var nextKey=0;
  var proto={
    /**
     * @param {object} data the data to be stored
     * @return {Number} key to retrieve the data
     */
    store:function(data){
      var key=nextKey++;
      this[key]=data;
      return key;
    },
    /**
     * @param {function} forEach similar effect to array
     */
    forEach:function(call){
      for (var key in this) {
        if (this.hasOwnProperty(key)){
          call(this[key],Number(key),this);
        }
      }
    }
  };
  var f=function(){
  };
  f.prototype=proto;
  return f;
});

/**
 * This provides a generic wrapper for web worker.
 * It allows async function call to the worker through Promise,
 * and allows worker to send back debug information,
 * return value, error message.
 * The worker can be stopped, reinitialized any time,
 * without constructing new Worker.
 *
 * @see {@link js/workerTemplate} for API of the worker
 * 
 * @module js/worker
 */

define('js/worker.js',["./text_to_url.js","./tokens.js"],function(t2u,Tokens){

var onmessageHelper=function (self,e)
{
  if(e.data.log){
    console.log(e.data.log);
  }
  if(e.data.hasOwnProperty("rtn")){
    self.tokens[e.data.token].a(e.data.rtn);
    delete self.tokens[e.data.token];
  }
  if(e.data.error){
    self.tokens[e.data.token].b(e.data.error);
    delete self.tokens[e.data.token];
  }
};
var onerrorHelper=function (self,e)
{
  //TODO handle
  console.error(e);
  if(e.data.token){
    self.tokens[e.data.token].b(e.data.error);
    delete self.tokens[e.data.token];
  }else{
    
  }
};
var getWorker=function (str)
{
  var worker = new Worker(t2u(str,"text/javascript"));
  var self=this;
  worker.onmessage=function(e){return onmessageHelper(self,e);};
  worker.onerror=function(e){return onerrorHelper(self,e);};
  return worker;
};

var proto=
{
  /**
   * this stops the worker and restart a new one
   * @param {String} str the source code of the worker
   * @return {Promise} none, when finished initializing
   */
  init:function(str)
  {
    this.stop();
    this.worker=getWorker.call(this,str);
  },
  /**
   * instantly stop worker
   * @return undefined
   */
  stop:function()
  {
    if(this.worker!==null){
      var self=this;
      this.tokens.forEach(function(value,token){
        //console.log(self.tokens[token]);
        value.b("worker stopped");
      });
      this.tokens=new Tokens();
      this.worker.terminate();
      this.worker=null;
    }
  },
  /**
   * simulate calling an async method
   * @return {Promise} simulate async return
   */
  call:function()
  {
    var args=arguments;
    var self=this;
    var list=Array(args.length+1);
    for(var t=0;t<args.length;t++){
      list[t+1]=args[t];
    }
    return new Promise(function(a,b){
      var token=self.tokens.store({a:a,b:b});
      list[0]=token;
      self.worker.postMessage(list);
    });
  }
};
var workergen=function()
{
  this.worker=null;
  this.tokens=new Tokens();
  this.promise=Promise.resolve();
};
workergen.prototype=proto;
return workergen;
});

/**
 * requirejs module for bot player
 * It creates a Web Worker that encapsolates bot
 * @see {@link bot/template} for api of bot
 */
define('js/player/bot.js',['../PlayerError.js','../worker.js','../tokens.js','Promise'],
function(PlayerError,Worker,Tokens,Promise){
  var BotError=function(message,error){
    PlayerError.call(this,message,error);
  };
  BotError.prototype=new PlayerError();
  /**
   * list of errors that will be throwed:
   * bot player: cannot load source from uri: (uri)
   * bot player: cannot understand source format from uri
   * bot player: cannot parse source: (message)
   * bot player: cannot load data from url: (url)
   * (error thrown by bot)
   * @param {String} param.boturi uri of the bot source 
   * @param {Object} param.botparam custom param for the bot
   * @param {String} param.dataurl url of the data used to get data
   * If it ends with '?' or '&' the player will append the attribute
   * with key being "hash" and value being the md5 of the string form of param.
   * If it is empty string, then data will be undefined
   */
  var init = function(param)
  {
    var worker=new Worker();
    var workerCall=function(){
      var args=arguments;
      return worker.call.apply(worker,args)
      .catch(function(error){
        throw new BotError("At calling worker."+args[0]+":"+error.message,error);
      });
    };
    return Promise.resolve($.ajax({
      url:param.boturi
    }))
    .catch(function(error){
      var botError=new BotError("Cannot load bot source from uri. message: "+error.statusText+".", error);
      throw botError;
    })
    .then(function(str)//get dataparam
    {
      try{
        if(param.boturi.indexOf("api.github.com/repos")!==-1){
          str=atob(str.content.replace(/\n/g,""));
          //console.log(str);
        }
      }catch(error){
        throw new BotError("Cannot read bot source from github",error);
      }
      try{
        worker.init(str);
      }catch(error){
        throw new BotError("Cannot parse bot source, message: "+error.message,error);
      }
    })
    .then(function()
    {
      var uri=param.dataurl;
      try{
        if(uri===""){
          return undefined;
        }
        var end=uri[uri.length-1];
        if(end==='?'||end==='&'){
          var hash=JSON.stringify(param);
          uri+="hash="+hash;
        }
      }catch(error){
        throw new BotError("Cannot general data uri. message: error",error);
      }
      return Promise.resolve($.ajax(
      {
        url:uri,
        dataType:"json"
      }))
      .catch(function(error){
        console.warn("Error loading bot data");
        //console.warn(error);
        console.warn("Using undefined as data");
        return undefined;
      });
    })
    .then(function(data)//init bot
    {
      return workerCall("init",param.botparam,data)
      .catch(function(error){
        throw new BotError("Cannot init bot.",error);
      });
    })
    .then(function(){//return
      return {
        getHand:function(h0,h1,dt)
        {
          return workerCall("update",h0,h1,dt).then(function(){
            return workerCall("getHand");
          });
        },
        stop:function()
        {
          worker.stop();
        }
      };
    });
  };
  return init;
});

define('js/consts.js',[],function(){
  var f= {
    randomInt:function(n)
    {
      return Math.random()*n | 0;
    },
    abbr:["r","p","s",'x'],
    result:["TIE","LOSE","WIN","UNKNOWN"],
    bottext:[
      [
        "Interesting play.",
        "Tie is not good enough!"
      ],
      [
        "I knew I would beat you!",
        "Your mind is too easy to guess.",
        "Don't be so easy on me."
      ],
      [
        "I can do better next time!",
        "I lost, that's impossible!",
        "How did I loose?"
      ],
      [
        "I'm broken... %&#$@^"
      ],
      [
        "I'm ready to play!"
      ]
    ]
  };
  var max=0;
  f.bottext.forEach(function(e){
    e.forEach(function(x){
      max=max>x.length?max:x.length;
    });
  });
  f.bottext.forEach(function(e){
    e.forEach(function(e,i,a){
      a[i]=e+Array(max-e.length+1).join(" ");
    });
  });
  return f;
});

define('js/main2.js',["./game.js","./player/bot.js","./consts.js"],
function(Game,Bot,consts){
  //define helper
  var getParam=function(i)
  {
    return {
      boturi:$("#source"+i).val(),
      dataurl:$("#data"+i).val(),
      botparam:$("#param"+i).val()
    };
  };
  var updateStat=function(count)
  {
    var sum=count[0]+count[1]+count[2];
    var getPersent=function(i){
      if(sum===0){
        return (100/3)+"%";
      }else{
        return ((100*count[i]/sum+0.5)|0)+"%";
      }
    };
    $("#s_bar > div").each(function(i){
      i=(i+2)%3;
      $(this).css("width",getPersent(i));
    });
    $("#s_text > span").each(function(i){
      if(i===0){
        this.innerHTML=sum;
        return;
      }
      //change order for gui
      i=(i-1+2)%3;
      this.innerHTML=count[i];
    });
  };
  var updateResult=function(h0,h1){
    $("#gr_0 > img")
      .attr("src","asset/rps_"+consts.abbr[h0]+"0.jpg")
      .toggleClass("gr_0i0")
      .toggleClass("gr_0i1");
    $("#gr_1 > img")
      .attr("src","asset/rps_"+consts.abbr[h1]+"1.jpg")
      .toggleClass("gr_1i0")
      .toggleClass("gr_1i1");
  };
  var setBottext=function(win){
    var array=consts.bottext[win];
    $("#g_bottext").text(array[consts.randomInt(array.length)]);
  };
  global=setBottext;

  //define game
  var game;
  var param1,param2;
  var game_start=function()
  {
    //global=game;
    var h01=game.history[game.history.length-1];
    if(h01===undefined){
      h01=15;
      return;
    }
    var h0=h01&3;
    var h1=(h01/4)&3;

    //update result
    //updateResult(h0,h1);

    //update history
    $("#rh_tbody").prepend(
        $("#w_roundR").html()
        .replace("td>1</td","td>"+game.history.length+"</td")
        .replace(/x(?=(0\.jpg))/,consts.abbr[h0])
        .replace(/x(?=(1\.jpg))/,consts.abbr[h1])
        .replace(/TIE/,consts.result[(h1-h0+3)%3])
        );

    //update stat
    var count=[0,0,0];
    game.history.forEach(function(h01){
        var h0=h01&3;
        var h1=(h01/4)&3;
        var win=(h1-h0+3)%3;
        if(h0===3){
        win=1;
        }
        if(h1===3){
        win=2;
        }
        count[win]++;
        });
    updateStat(count);

    //update bot
    var win=(h1-h0+3)%3;
    //setBottext(win);
    //TODO
  };
  var nth=function(){};
  var game_end=function(message)
  {
    console.log("end!!!");
    //update bot
    if(message instanceof Error){
      setBottext(3);
    }else{
      //$("#g_bottext").text("Game ended. Happy to play with you again!");

    }

    //global=game;
  };
  var startGame=function()
  {
    $("#rh_tbody").html("");
    if(game!==undefined){
      updateResult(3,3);
      //setBottext(4);
      //$("#g_bottext").text("I'm ready to play!");
    }
    updateStat([0,0,0]);
    param1=getParam(0);
    param2=getParam(1);
    var hands=$("#g_hand > div").toArray();
    var p1=Bot(param1);
    var p2=Bot(param2);
    game=Game(p1,p2,0,game_start,nth,nth,game_end,Number($("#round").val()));
  };
  var resetGame=function()
  {
    if(game!==undefined){
      //STOP
      game.terminate();
    }
    startGame();
  };

  $("#run").on("click",function(){resetGame();return false;});
  
  

});
